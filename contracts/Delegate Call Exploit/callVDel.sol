// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

/*
    How the exploit comes into existence:
    A naive developer uses delegate call
    He knows that delegate call can be used to change state variables of 'caller' contract.
    And he intends for one of his state variables to be changed. He names them to be 
    the same as the ones in the library or calling contract.

    However, he does not understand how storage layout works in solidity
    The slots are sometimes the same for values. However, if the size exceeds 32 bytes, then a new slot is generated.
    Regardless, read the solidity docs for more info

    Now, the target variable is interchanged and instead, the address of owner of contract is declared first.
    This causes the address of owner to change!
    Essentially leading to a DOS Attack!

    Also, the creator of vulnerable contract has allowed a fallback function to pass data 'as is' to the library via a delegate call

    From here, the exploit begins.
*/

contract delegateLibrary {
    uint public number;
    function changeNum (uint seed) external {
        number = seed;
        //Consider this function to be a pseudo-random number generator.
        // The working of the function is abstracted.
    }
}

contract VulnDelegator {
    address public owner;
    uint public number;
    address public libr;

    constructor (address _libr) {
        libr = _libr;
        owner = msg.sender;
    }

    function proclaimOwnership() public view returns (string memory) {
        require(owner == msg.sender, "You are not the owner!");
        return "Yes I am still the owner!";
    }

    fallback() external  {
        libr.delegatecall(msg.data);
    }

}